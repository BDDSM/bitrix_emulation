Перем ВнутреннийКэш;//Соответствие

Функция ПараметрыСоединенияES()
	Возврат Новый Структура("Сервер,Порт","localhost",9200);
КонецФункции

Функция СтрокаСоединенияES() Экспорт
	Возврат "http://localhost:9200/";
КонецФункции

Функция СоединениеES()
	
	Результат = ЭДО_Кэш_Прочитать("СоединениеES");
	
	Если Результат=Неопределено Тогда
		
		Сервер	= ПараметрыСоединенияES().Сервер;
		Порт	= ПараметрыСоединенияES().Порт;
		
		//Сервер = "localhost";
		Прокси = Неопределено;
		
		//Порт = 443;
		//ЗащищенноеСоединение = Истина;//для 8.3 будет по-другому. Точнее, на месте этого параметра будет стоять таймаут. Бред, короче.
		
		//Порт = 80;
		ЗащищенноеСоединение = Ложь;//для 8.3 будет по-другому. Точнее, на месте этого параметра будет стоять таймаут. Бред, короче.
		
		Если МетодРаботыAPI() = "Native" Тогда
			
//			Результат = Новый HTTPСоединение(Сервер, Порт, , , Прокси, , Новый ЗащищенноеСоединениеOpenSSL);
			Результат = Новый HTTPСоединение(Сервер, Порт, , , Прокси, , );
		
		ИначеЕсли МетодРаботыAPI() = "COM" Тогда	
			
			Результат = Новый COMОбъект("WinHttp.WinHttpRequest.5.1");
			//Результат.Option(2,"UTF-8");                   
		
		КонецЕсли;
		
//		Результат = Новый HTTPСоединение(Сервер, Порт, , , Прокси, ЗащищенноеСоединение);
		ЭДО_Кэш_Поместить("СоединениеES",Результат);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ЭДО_Кэш_Прочитать(ИмяЗначения)
	
	Если ВнутреннийКэш = Неопределено Тогда
		Возврат Неопределено;
	Иначе
		Возврат ВнутреннийКэш.Получить(ИмяЗначения);
	КонецЕсли;
	
КонецФункции

Процедура ЭДО_Кэш_Поместить(ИмяЗначения,Значение)
	
	Если ВнутреннийКэш = Неопределено Тогда
		ВнутреннийКэш = Новый Соответствие;
	КонецЕсли;
	
	ВнутреннийКэш.Вставить(ИмяЗначения,Значение);
	
КонецПроцедуры

Функция EDI_РазложитьСтрокуВМассивСлов(Знач Строка, РазделителиСлов="") Экспорт
	
	Слова = Новый Массив;
	
	Для Сч = 1 По СтрДлина(РазделителиСлов) Цикл
		Строка = СтрЗаменить(Строка,Сред(РазделителиСлов,Сч,1),Символы.ПС);
	КонецЦикла;
	
	Для Сч=1 По СтрЧислоСтрок(Строка) Цикл
		ТекСлово = СокрЛП(СтрПолучитьСтроку(Строка,Сч));
		Если ТекСлово<>"" Тогда
			Слова.Добавить(ТекСлово);
		КонецЕсли;	
	КонецЦикла;	
	
	Возврат Слова;
	
КонецФункции


//платформы ниже 8.3 придется заворачивать на WinHTTPRequest через COM
Функция API_ВызватьМетод(АдресЗапроса,Метод,УчетнаяЗапись,ТекстФайла="") Экспорт
	
	Результат = Неопределено;
	
	//ИмяФайлаОтвета=ПолучитьИмяВременногоФайла();
	
	Заголовки = Новый Соответствие;
	//Заголовки.Вставить("Accept","application/json");//без этого вернется протобуфер
	//Заголовки.Вставить("Content-Type","application/json; charset=utf-8");//для отправки в JSON вместо protobuf
	
	Результат = _СобственноВыполнениеЗапроса(СоединениеES(),АдресЗапроса,"",Заголовки,Метод,ТекстФайла);
	
	Возврат Результат;
	
КонецФункции	

Функция РазобратьОтвет(Ответ) Экспорт
	
	ИмяВремФайла = ПолучитьИмяВременногоФайла();
	ТД = Новый ТекстовыйДокумент;
	ТД.УстановитьТекст(Ответ);
	ТД.Записать(ИмяВремФайла,"UTF-8");
	
	Чтение = Новый ЧтениеJSON;
//	Чтение.УстановитьСтроку(Ответ);
	Чтение.ОткрытьФайл(ИмяВремФайла,"UTF-8");
	Результат = ПрочитатьJSON(Чтение);
	Чтение.Закрыть();

	Попытка
		УдалитьФайлы(ИмяВремФайла);
	Исключение
		//отладка
	КонецПопытки;	
	
	Возврат Результат;
	
КонецФункции

Функция _СобственноВыполнениеЗапроса(Соединение,АдресЗапроса,Параметры="",Заголовки,Метод,ТекстФайла="")//ТекстФайла - для POST
	
	Результат = Неопределено;
	ПолныйАдрес = АдресЗапроса+?(Параметры="","","?")+Параметры;
	ИмяФайлаОтвета = ПолучитьИмяВременногоФайла();
	
	Если МетодРаботыAPI()="Native" Тогда
		
		Если Метод = "GET" Тогда
			Соединение.Получить(ПолныйАдрес,ИмяФайлаОтвета,Заголовки);
		ИначеЕсли Метод = "DELETE" Тогда
			_Запрос = Новый HTTPЗапрос;
			_Запрос.АдресРесурса = ПолныйАдрес;
			_Запрос.Заголовки = Заголовки;
			
			//Соединение.Удалить(ПолныйАдрес,ИмяФайлаОтвета,Заголовки);
			Соединение.Удалить(_Запрос);
		ИначеЕсли Метод = "POST" Тогда
			
			_Запрос = Новый HTTPЗапрос(ПолныйАдрес);
			_Запрос.УстановитьТелоИзСтроки(ТекстФайла,"UTF-8",ИспользованиеByteOrderMark.НеИспользовать);//BOM обязательно отключить!
			_Запрос.Заголовки = Заголовки;
			
//			Соединение.ОтправитьДляОбработки(_Запрос,ИмяФайлаОтвета);
			Соединение.ОтправитьДляОбработки(_Запрос);
			
		КонецЕсли;
		
		//ТД=Новый ТекстовыйДокумент;
		//ТД.Прочитать(ИмяФайлаОтвета,КодировкаТекста.UTF8);
		//Результат=ТД.ПолучитьТекст();
		Результат = _Запрос.ПолучитьТелоКакСтроку();
		
		//НачатьУдалениеФайлов(,ИмяФайлаОтвета);
		#Если Клиент Тогда
		//УдалитьФайлы(ИмяФайлаОтвета);
		#Иначе	
		УдалитьФайлы(ИмяФайлаОтвета);
		#КонецЕсли
		
	ИначеЕсли МетодРаботыAPI()="COM" Тогда
		
		АдресАпи = "https://diadoc-api.kontur.ru";
		Соединение.Open(Метод,АдресАпи+ПолныйАдрес,0);
		 
		Для Каждого Заголовок Из Заголовки Цикл
			Соединение.SetRequestHeader(Заголовок.Ключ, Заголовок.Значение);
		КонецЦикла;
		        
		Соединение.Send(ТекстФайла);// Параметром передаем POST-данные для страници тут как раз
		Результат = Соединение.ResponseText();
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

//просто добавляет переносы строк в JSON
Функция ЧитабельныйОтвет(Ответ) Экспорт
	Результат = Ответ;
	
	Для Каждого Символ Из EDI_РазложитьСтрокуВМассивСлов("{ ["," ") Цикл
		Результат = СтрЗаменить(Результат,Символ,Символы.ПС+Символ);
	КонецЦикла;
	
	Для Каждого Символ Из EDI_РазложитьСтрокуВМассивСлов("} ]"," ") Цикл
		Результат = СтрЗаменить(Результат,Символ,Символ+Символы.ПС);
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

Функция МетодРаботыAPI()
	
	Возврат "Native";
	//Возврат "COM";

КонецФункции


Функция ES_API_SearchIndexes(boxId,messageId,entityId="") Экспорт
	
	_Параметры = "boxId="+boxId+"&messageId="+messageId;
	Если Не ПустаяСтрока(entityId) Тогда
		_Параметры = _Параметры+"&entityId="+entityId;
	КонецЕсли;
	
	Возврат API_ВызватьМетод("/V3/GetMessage?"+_Параметры,"GET","","");
	
КонецФункции

Функция ES_API_Goods_Create(parentId,itemId,RequestBody) Экспорт
	//да, и тут не хватает владельца: чей каталог создаем/обновляем.
	
	//вот здесь, кажется, имеет смысл брать составной id: guid каталога и guid товара. Может, еще плюсом guid владельца.	
	Возврат API_ВызватьМетод("/cat/"+parentId+"/"+itemId,"POST","",RequestBody);
	
КонецФункции

Функция СтрокаТаблицыВСтруктуру(СтрокаТаблицы) Экспорт
	
	Результат = Новый Структура;
	
	Для Каждого Колонка Из СтрокаТаблицы.Владелец().Колонки Цикл
		Результат.Вставить(Колонка.Имя,СтрокаТаблицы[Колонка.Имя]);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция СтруктураВJSON(Структура) Экспорт
	
	Запись = Новый ЗаписьJSON;
	Запись.УстановитьСтроку();
	
	ЗаписатьJSON(Запись,Структура);
	
	Результат = Запись.Закрыть();
	
	Возврат Результат;
	
КонецФункции	

//брехня
Функция Описание()
	
	//ES имеет структуру:
	//http://localhost:9200/<индекс>/<тип>/<элемент>
	
	//где <индекс> - вроде БД
	//<тип> - таблица
	//<элемент> - запись в таблице
	
	
	//значит, у нас будут типы:
	//1. Просто товары с полями: Владелец, Каталог, GTIN, Код, Наименование и т.д.
	//2. Каталоги с полями: Владелец, Наименование, [теги] (?)
	//3. Владельцы с полями: Наименование, ИНН, КПП, [теги] (?)
	
	
	
	//как обработать входящий каталог CML?
	//1. Создать владельца и каталог, видимо.
	//2. Разобранные товары кинуть в ES. Что там с обновлениями? Как избегать конфликтов?
	
	//дак вот, разбор можно той обработкой.
	
	
	
	
	
	
	//**************************************************************//
	
	
	//теперь подумаем над API
	
	//надо уметь делать такие вещи:
	//1) Поиск описания товара (название, GTIN, ...) в различных каталогах
	//2) Вывод самих каталогов в CML. Т.е. преобразование кучи записей ES в CommerceML
	//3) Вывод списка зарегистрированных компаний
	//4) А также какой-то механизм регистрации
	
	
	//и еще одна проблема сразу: состав полей в разных каталогах разный, но при этом тип "goods" у нас один и тот же. Видимо, доп.поля будем отдельными тегами делать.
	
КонецФункции	

Процедура РазобратьИПоместитьКаталогВЭластик(ИмяФайла,ИДКаталога,Парсер) Экспорт
	
	Таблицы = Парсер.РазобратьXMLВТаблицыЗначений(ИмяФайла);
	
	СтрокаОсновныхПолей = "";
	СтрокаПроизвольныхПолей = "";
	
	Для Каждого КолонкаТоваров Из Таблицы.ТаблицаТоваров.Колонки Цикл
		
		// Соберем строку, после чего разобьем ТаблицаТоваров пополам,
		// так как дополнительные реквизиты будем закидывать во вложенную структуру.
		
		Если Таблицы.СтруктураДопПолей.Найти(КолонкаТоваров.Имя,"ВнутреннееИмя")=Неопределено Тогда
			СтрокаОсновныхПолей = ?(СтрокаОсновныхПолей="","",СтрокаОсновныхПолей+",")+КолонкаТоваров.Имя;//основное поле
		Иначе	
			СтрокаПроизвольныхПолей = ?(СтрокаПроизвольныхПолей="","",СтрокаПроизвольныхПолей+",")+КолонкаТоваров.Имя;//произвольное поле
		КонецЕсли;	
		
	КонецЦикла;	
	
	ТаблицаОсновныхПолей = Таблицы.ТаблицаТоваров.Скопировать(,СтрокаОсновныхПолей);
	ТаблицаПроизвольныхПолей = Таблицы.ТаблицаТоваров.Скопировать(,СтрокаПроизвольныхПолей);
	
	ШаблонПрефикса = "{ ""index"" : { ""_index"" : ""cat"", ""_type"" : ""<ID_TYPE>"", ""_id"" : ""<ID_ITEM>"" } }";
	_Поток = Новый ЗаписьXML;
	_Поток.УстановитьСтроку();
	Символ10 = Символ(10);
	Для Сч=0 По ТаблицаОсновныхПолей.Количество()-1 Цикл
		
		СтруктураДокумента = СтрокаТаблицыВСтруктуру(ТаблицаОсновныхПолей[Сч]);
		СтруктураДокумента.Вставить("ПроизвольныеПоля", СтрокаТаблицыВСтруктуру(ТаблицаПроизвольныхПолей[Сч]));
		//здесь надо вычленить все доп.поля в отдельный вложенный массив
		//а человеческие имена этих полей дадим в отдельной сущности: каталоги
		
		ИДТовара = ТаблицаОсновныхПолей[Сч].Код;
		
		_ТекстПрефикса = ШаблонПрефикса;
		_ТекстПрефикса = СтрЗаменить(_ТекстПрефикса,"<ID_TYPE>",ИДКаталога);
		_ТекстПрефикса = СтрЗаменить(_ТекстПрефикса,"<ID_ITEM>",ИДТовара);
		
		//СтруктураДокумента.Наименование = "Префикс"+Символы.ПС+СтруктураДокумента.Наименование;//тест
		_ТекстТовара = СтруктураВJSON(СтруктураДокумента);
		
		//ES_API_Goods_Create(ИДКаталога,ИДТовара,_ТекстТовара);
		_ТекстТовара = СтрЗаменить(_ТекстТовара,Символы.ПС,"");  //иначе не пройдет через bulk
		_ТекстТовара = СтрЗаменить(_ТекстТовара,Символы.ВК,"");
//		_ТекстТовара = СтрЗаменить(_ТекстТовара,Символ10+"}","}");
		
		_Поток.ЗаписатьБезОбработки(?(Сч=0,"",Символы.ПС)+_ТекстПрефикса+Символы.ПС+_ТекстТовара);
		
		//Прервать;//отладка
		
	КонецЦикла;
	
	_ТекстПакета = _Поток.Закрыть();
	Результат = API_ВызватьМетод("/_bulk","POST","",_ТекстПакета);//запишем все данные одним пакетом.
	
КонецПроцедуры

Процедура ПоместитьРазобранныйКаталогВЭластик(РазобранныйКаталог) Экспорт
	
	СтрокаОсновныхПолей = "";
	СтрокаПроизвольныхПолей = "";
	
	Для Каждого КолонкаТоваров Из РазобранныйКаталог.ТаблицаТоваров.Колонки Цикл
		
		// Соберем строку, после чего разобьем ТаблицаТоваров пополам,
		// так как дополнительные реквизиты будем закидывать во вложенную структуру.
		
		Если РазобранныйКаталог.СтруктураДопПолей.Найти(КолонкаТоваров.Имя,"ВнутреннееИмя")=Неопределено Тогда
			СтрокаОсновныхПолей = ?(СтрокаОсновныхПолей="","",СтрокаОсновныхПолей+",")+КолонкаТоваров.Имя;//основное поле
		Иначе	
			СтрокаПроизвольныхПолей = ?(СтрокаПроизвольныхПолей="","",СтрокаПроизвольныхПолей+",")+КолонкаТоваров.Имя;//произвольное поле
		КонецЕсли;	
		
	КонецЦикла;	
	
	ТаблицаОсновныхПолей = РазобранныйКаталог.ТаблицаТоваров.Скопировать(,СтрокаОсновныхПолей);
	ТаблицаПроизвольныхПолей = РазобранныйКаталог.ТаблицаТоваров.Скопировать(,СтрокаПроизвольныхПолей);
	
	ШаблонПрефикса = "{ ""index"" : { ""_index"" : ""cat"", ""_type"" : ""<ID_TYPE>"", ""_id"" : ""<ID_ITEM>"" } }";
	_Поток = Новый ЗаписьXML;//это на порядок быстрее "сложения" строк
	_Поток.УстановитьСтроку();
	Для Сч=0 По ТаблицаОсновныхПолей.Количество()-1 Цикл
		
		СтруктураДокумента = СтрокаТаблицыВСтруктуру(ТаблицаОсновныхПолей[Сч]);
		СтруктураДокумента.Вставить("ПроизвольныеПоля", СтрокаТаблицыВСтруктуру(ТаблицаПроизвольныхПолей[Сч]));
		//здесь надо вычленить все доп.поля в отдельный вложенный массив
		//а человеческие имена этих полей дадим в отдельной сущности: каталоги
		
		ИДТовара = ТаблицаОсновныхПолей[Сч].Код;
		
		_ТекстПрефикса = ШаблонПрефикса;
		_ТекстПрефикса = СтрЗаменить(_ТекстПрефикса,"<ID_TYPE>",РазобранныйКаталог.ОбщаяИнформация.ИДКаталога);//еще здесь доступно ИДОрганизации
		_ТекстПрефикса = СтрЗаменить(_ТекстПрефикса,"<ID_ITEM>",ИДТовара);
		
		//СтруктураДокумента.Наименование = "Префикс"+Символы.ПС+СтруктураДокумента.Наименование;//тест
		_ТекстТовара = СтруктураВJSON(СтруктураДокумента);
		
		//ES_API_Goods_Create(ИДКаталога,ИДТовара,_ТекстТовара);
		//СтруктураДокумента.Наименование="НАЙДИ МЕНЯ";
		//ES_API_Goods_Create(РазобранныйКаталог.ОбщаяИнформация.ИДКаталога,ИДТовара,СтруктураВJSON(СтруктураДокумента));//найдем подлеца
		
		_ТекстТовара = СтрЗаменить(_ТекстТовара,Символы.ПС,"");  //иначе не пройдет через bulk
		_ТекстТовара = СтрЗаменить(_ТекстТовара,Символы.ВК,"");
//		_ТекстТовара = СтрЗаменить(_ТекстТовара,Символ10+"}","}");
		
		_Поток.ЗаписатьБезОбработки(?(Сч=0,"",Символы.ПС)+_ТекстПрефикса+Символы.ПС+_ТекстТовара);
		
		//Прервать;//отладка
		//еще проблема: последний элемент исчезает.
		
	КонецЦикла;
	
	_ТекстПакета = _Поток.Закрыть()+Символы.ПС;
	Результат = API_ВызватьМетод("/_bulk","POST","",_ТекстПакета);//запишем все данные одним пакетом.
	
КонецПроцедуры

